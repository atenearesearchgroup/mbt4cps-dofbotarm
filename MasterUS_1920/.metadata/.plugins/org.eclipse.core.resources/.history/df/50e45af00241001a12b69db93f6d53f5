/*
 * generated by Xtext 2.20.0
 */
package lsi.us.es.mis.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lsi.us.es.mis.xtext.myWorldDsl.World
import java.util.List
import lsi.us.es.mis.xtext.myWorldDsl.Continent
import lsi.us.es.mis.xtext.myWorldDsl.Ocean
import lsi.us.es.mis.xtext.myWorldDsl.Sea
import lsi.us.es.mis.xtext.myWorldDsl.Lake
import lsi.us.es.mis.xtext.myWorldDsl.Country

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * 
 * Author: jtroya
 */
 
/**************************** CODE TO GENERATE THE TEXTUAL DESCRIPTION FILE ********************************************/
class MyWorldDslGenerator extends AbstractGenerator {
	//Variable fsa of type IFileSystemAccess will be used for creating the generated file
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		//The file we must create (functions classNAme and toCode must be implemented)
		fsa.generateFile(resource.className + ".txt", //The extension that we want to have in our generated file
			toCode(resource.contents.head as World)
		)
	}
	
	//We define a function className that will be used to obtain the name of the file with extension 'wrld'
	def className(Resource res){
		//We don't need to specify variable types
		var name = res.URI.lastSegment //We assign the name of the ctry file
		return name.substring(0, name.indexOf('.')) //And return the part that is before the extension of the file
		//For instance, if we have sample.wlrd, then we obtain name sample.txt
	}
	
	def toCode(World world){
		//The following code creates the file automatically
'''This file has been created automatically
   This is for printing the name of the first space: «world.spaces.get(0).name»
   
   
	«getNumberSpaces(world).get(0)» continent«IF getNumberSpaces(world).get(0) != 1»s«ENDIF», 
	«getNumberSpaces(world).get(1)» countrie«IF getNumberSpaces(world).get(1) != 1»s«ENDIF», 
	«getNumberSpaces(world).get(2)» ocean«IF getNumberSpaces(world).get(2) != 1»s«ENDIF», 
	«getNumberSpaces(world).get(3)» sea«IF getNumberSpaces(world).get(3) != 1»s«ENDIF» and 
	«getNumberSpaces(world).get(4)» lake«IF getNumberSpaces(world).get(4) != 1»s«ENDIF» 
	
	
A more detailed analysis reveals the following.
	
Places with water:
«FOR space : world.spaces»
	«IF space.eClass.name.equals("Ocean")»
	«var ocean = space as Ocean /*This way we are able to access Ocean's attributes */»
		«ocean.name» Ocean has an area of «ocean.area» square kilometers and a volume of «ocean.ck» cubic kilometers
	«ELSEIF space.eClass.name.equals("Sea")»
	«var sea = space as Sea»
		«sea.name» Sea has an area of «sea.area» square kilometers and a volume of «sea.ck» cubic kilometers
	«ELSEIF space.eClass.name.equals("Lake")»
	«var lake = space as Lake»
		Lake «lake.name» has an area of «lake.area» square kilometers and a volume of «lake.ck» cubic kilometers
	«ENDIF»
«ENDFOR»
	
Regarding inland places:
«FOR space : world.spaces»
	«IF space.eClass.name.equals("Continent")»
		«var continent = space as Continent»
			«continent.name» is a continent with an area of «continent.area» square kilometers. It contains the following countries:
		«FOR country : continent.countries»	
			«country.name». «IF country.peaceful»This peaceful country«ELSE»It«ENDIF» has an area of «country.area» square kilometers and a population of «country.population» inhabitants, what means a density of «Double.parseDouble(country.population) / Double.parseDouble(country.area)».
			«IF country.washedBy.size>0»
				«writeWashedByWaters(country) /*The information related to the waters that wash the country is printed by method writeWashedByWaters*/» 
			«ENDIF»
		«ENDFOR»
			This means that the population of «continent.name» is «getContinentPopulation(continent)»
	«ENDIF»
«ENDFOR»
'''
		
	}
	
	//This method returns an array with the number of continents, countries, oceans, lakes and seas
	def getNumberSpaces(World world){
		val result = newArrayList()
		var continents = 0
		var countries = 0
		var oceans = 0
		var lakes = 0
		var seas = 0
		
		for (space : world.spaces){
			if (space.eClass.name.equals("Continent")){ //We access the metadata of "space" (Eclass name)
				continents++
				//By using the reflective API, we get the countries that the continent has
				var ctries = space.eGet(space.eClass().getEStructuralFeature("countries")) as List
				countries += ctries.size
			} 			
			if (space.eClass.name.equals("Ocean")) oceans++		
			if (space.eClass.name.equals("Sea")) seas++		
			if (space.eClass.name.equals("Lake")) lakes++		
		}
		result.add(continents)
		result.add(countries)
		result.add(oceans)
		result.add(seas)
		result.add(lakes)
		return result
	}
	
	//This method returns the population of a continent by adding the populations of its countries
	def getContinentPopulation(Continent continent){
		var result = 0
		for (country : continent.countries) result += Integer.parseInt(country.population)
		return result
	}
	
	//This methods prints the waters that wash a country, all in one line, and it returns such String
	def writeWashedByWaters(Country country){
		var result = ""
		result += country.name + " is washed by " + country.washedBy.get(0).name
		if (country.washedBy.get(0).eClass.name.equals("Ocean")) result += " Ocean"
		else if (country.washedBy.get(0).eClass.name.equals("Sea")) result += " Sea"
		else result += " Lake"
		for (water : country.washedBy){
			if (country.washedBy.indexOf(water)!=0){ //Because we have already printed the first one
				result += ", " + water.name
				if (water.eClass.name.equals("Ocean")) result += " Ocean"
				else if (water.eClass.name.equals("Sea")) result += " Sea"
				else result += " Lake"
			}
		}
		return result
	}
}
/**************************** END OF CODE TO GENERATE THE TEXTUAL DESCRIPTION FILE ********************************************/

/************************************* CODE TO GENERATE THE YAML FILE ********************************************************/
//class MyWorldDslGenerator extends AbstractGenerator {
//	//Variable fsa of type IFileSystemAccess will be used for creating the generated file
//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//
//		//The file we must create (functions classNAme and toCode must be implemented)
//		fsa.generateFile(resource.className + ".yaml", //The extension that we want to have in our generated file
//			toCode(resource.contents.head as World)
//		)
//	}
//	
//	//We define a function className that will be used to obtain the name of the file with extension 'wrld'
//	def className(Resource res){
//		//We don't need to specify variable types
//		var name = res.URI.lastSegment //We assign the name of the ctry file
//		return name.substring(0, name.indexOf('.')) //And return the part that is before the extension of the file
//		//For instance, if we have sample.wlrd, then we obtain name sample.yaml
//	}
//	
//	def toCode(World world){
//		//The following code creates the file automatically
//	var result = "world:\n"
//	result += tab + "spaces:\n"
//	for (space : world.spaces){
//		if (space.eClass.name.equals("Continent")){ //We access the metadata of "space" (Eclass name)
//			var continent = space as Continent
//			result += tab + tab + "- continent:\n"
//			result += tab + tab + tab + "name: " + continent.name + "\n"
//			result += tab + tab + tab + "area: " + continent.area + "\n"
//			result += tab + tab + tab + "population: " + getContinentPopulation(continent) + " #This is calculated according to continent's countries\n"
//			if (continent.countries.size > 0) result += tab + tab + tab + "countries:\n"
//			for(country : continent.countries){
//				result += tab + tab + tab + tab + "- country: &" + country.name + "\n"
//				result += tab + tab + tab + tab + tab + "name: " + country.name + "\n"
//				result += tab + tab + tab + tab + tab + "area: " + country.area + "\n"
//				result += tab + tab + tab + tab + tab + "population: " + country.population + "\n"
//				result += tab + tab + tab + tab + tab + "peaceful: " + country.peaceful + "\n"
//				if (country.borders.size > 0){
//					result += tab + tab + tab + tab + tab + "borders: [*" + country.borders.get(0).name
//					for (var i = 1; i<country.borders.size; i++){
//						result += ", *" + country.borders.get(i).name
//					}
//					result += "]\n" 
//				}
//				if (country.washedBy.size > 0){
//					result += tab + tab + tab + tab + tab + "washedBy: [*" + country.washedBy.get(0).name
//					for (var i = 1; i<country.washedBy.size; i++){
//						result += ", *" + country.washedBy.get(i).name
//					}
//					result += "]\n" 
//				}
//			}
//		} else if (space.eClass.name.equals("Ocean")){
//			var ocean = space as Ocean
//			result += tab + tab + "- ocean: &" + ocean.name + "\n"
//			result += tab + tab + tab + "name: " + ocean.name + "\n"
//			result += tab + tab + tab + "area: " + ocean.area + "\n"
//			result += tab + tab + tab + "volume: " + ocean.ck + "\n"
//		} else if (space.eClass.name.equals("Sea")){
//			var sea = space as Sea
//			result += tab + tab + "- sea: &" + sea.name + "\n"
//			result += tab + tab + tab + "name: " + sea.name + "\n"
//			result += tab + tab + tab + "area: " + sea.area + "\n"
//			result += tab + tab + tab + "volume: " + sea.ck + "\n"
//		} else if (space.eClass.name.equals("Lake")){
//			var lake = space as Lake
//			result += tab + tab + "- lake: &" + lake.name + "\n"
//			result += tab + tab + tab + "name: " + lake.name + "\n"
//			result += tab + tab + tab + "area: " + lake.area + "\n"
//			result += tab + tab + tab + "volume: " + lake.ck + "\n"
//		}
//	}
//	return result
//		
//	}
//	
//	def tab(){
//		return "  "
//	}
//	
//	//This method returns the population of a continent by adding the populations of its countries
//	def getContinentPopulation(Continent continent){
//		var result = 0
//		for (country : continent.countries) result += Integer.parseInt(country.population)
//		return result
//	}
//}

/********************************** END OF CODE TO GENERATE THE YAML FILE ********************************************************/
