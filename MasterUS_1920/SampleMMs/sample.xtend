/*
 * generated by Xtext 2.20.0
 */
package lsi.us.es.mis.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lsi.us.es.mis.xtext.myWorldDsl.World
import java.util.List
import lsi.us.es.mis.xtext.myWorldDsl.Continent
import lsi.us.es.mis.xtext.myWorldDsl.Ocean
import lsi.us.es.mis.xtext.myWorldDsl.Sea
import lsi.us.es.mis.xtext.myWorldDsl.Lake
import lsi.us.es.mis.xtext.myWorldDsl.Country

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * 
 * Author: jtroya
 */
 
/**************************** CODE TO GENERATE THE TEXTUAL DESCRIPTION FILE ********************************************/
class MyWorldDslGenerator extends AbstractGenerator {
	//Variable fsa of type IFileSystemAccess will be used for creating the generated file
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		//The file we must create (functions classNAme and toCode must be implemented)
		fsa.generateFile(resource.className + ".txt", //The extension that we want to have in our generated file
			toCode(resource.contents.head as World)
		)
	}
	
	//We define a function className that will be used to obtain the name of the file with extension 'wrld'
	def className(Resource res){
		//We don't need to specify variable types
		var name = res.URI.lastSegment //We assign the name of the ctry file
		return name.substring(0, name.indexOf('.')) //And return the part that is before the extension of the file
		//For instance, if we have sample.wlrd, then we obtain name sample.txt
	}
	
	def toCode(World world){
		//The following code creates the file automatically
		'''This file has been created automatically
   		This is for printing the name of the first space: «world.spaces.get(0).name» more text here
   '''
   }
}
/**************************** END OF CODE TO GENERATE THE TEXTUAL DESCRIPTION FILE ********************************************/

/************************************* CODE TO GENERATE THE YAML FILE ********************************************************/
//class MyWorldDslGenerator extends AbstractGenerator {
//	//Variable fsa of type IFileSystemAccess will be used for creating the generated file
//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
////		fsa.generateFile('greetings.txt', 'People to greet: ' + 
////			resource.allContents
////				.filter(Greeting)
////				.map[name]
////				.join(', '))
//
//		//The file we must create (functions classNAme and toCode must be implemented)
//		fsa.generateFile(resource.className + ".yaml", //The extension that we want to have in our generated file
//			toCode(resource.contents.head as World)
//		)
//	}
//	
//	//We define a function className that will be used to obtain the name of the file with extension 'wrld'
//	def className(Resource res){
//		//We don't need to specify variable types
//		var name = res.URI.lastSegment //We assign the name of the ctry file
//		return name.substring(0, name.indexOf('.')) //And return the part that is before the extension of the file
//		//For instance, if we have sample.wlrd, then we obtain name sample.yaml
//	}
//	
//	def toCode(World world){
//		//The following code creates the file automatically
//	var result = "world:\n"
//	result += tab + "spaces:\n"
//	for (space : world.spaces){
//		if (space.eClass.name.equals("Continent")){ //We access the metadata of "space" (Eclass name)
//			var continent = space as Continent
//			result += tab + tab + "- continent:\n"
//			result += tab + tab + tab + "name: " + continent.name + "\n"
//			result += tab + tab + tab + "area: " + continent.area + "\n"
//			result += tab + tab + tab + "population: " + getContinentPopulation(continent) + " #This is calculated according to continent's countries\n"
//			if (continent.countries.size > 0) result += tab + tab + tab + "countries:\n"
//			for(country : continent.countries){
//				result += tab + tab + tab + tab + "- country: &" + country.name + "\n"
//				result += tab + tab + tab + tab + tab + "name: " + country.name + "\n"
//				result += tab + tab + tab + tab + tab + "area: " + country.area + "\n"
//				result += tab + tab + tab + tab + tab + "population: " + country.population + "\n"
//				result += tab + tab + tab + tab + tab + "peaceful: " + country.peaceful + "\n"
//				if (country.borders.size > 0){
//					result += tab + tab + tab + tab + tab + "borders: [*" + country.borders.get(0).name
//					for (var i = 1; i<country.borders.size; i++){
//						result += ", *" + country.borders.get(i).name
//					}
//					result += "]\n" 
//				}
//				if (country.washedBy.size > 0){
//					result += tab + tab + tab + tab + tab + "washedBy: [*" + country.washedBy.get(0).name
//					for (var i = 1; i<country.washedBy.size; i++){
//						result += ", *" + country.washedBy.get(i).name
//					}
//					result += "]\n" 
//				}
//			}
//		} else if (space.eClass.name.equals("Ocean")){
//			var ocean = space as Ocean
//			result += tab + tab + "- ocean: &" + ocean.name + "\n"
//			result += tab + tab + tab + "name: " + ocean.name + "\n"
//			result += tab + tab + tab + "area: " + ocean.area + "\n"
//			result += tab + tab + tab + "volume: " + ocean.ck + "\n"
//		} else if (space.eClass.name.equals("Sea")){
//			var sea = space as Sea
//			result += tab + tab + "- sea: &" + sea.name + "\n"
//			result += tab + tab + tab + "name: " + sea.name + "\n"
//			result += tab + tab + tab + "area: " + sea.area + "\n"
//			result += tab + tab + tab + "volume: " + sea.ck + "\n"
//		} else if (space.eClass.name.equals("Lake")){
//			var lake = space as Lake
//			result += tab + tab + "- lake: &" + lake.name + "\n"
//			result += tab + tab + tab + "name: " + lake.name + "\n"
//			result += tab + tab + tab + "area: " + lake.area + "\n"
//			result += tab + tab + tab + "volume: " + lake.ck + "\n"
//		}
//	}
//	return result
//		
//	}
//	
//	def tab(){
//		return "  "
//	}
//	
//	//This method returns the population of a continent by adding the populations of its countries
//	def getContinentPopulation(Continent continent){
//		var result = 0
//		for (country : continent.countries) result += Integer.parseInt(country.population)
//		return result
//	}
//}

/********************************** END OF CODE TO GENERATE THE YAML FILE ********************************************************/
